<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <title>SRFI 170: POSIX API</title>
    <link href="/favicon.png" rel="icon" sizes="192x192" type="image/png">
    <link rel="stylesheet" href="https://srfi.schemers.org/srfi.css" type="text/css">
    <meta name="viewport" content="width=device-width, initial-scale=1"></head>
  <body>
    <h1><a href="https://srfi.schemers.org/"><img class="srfi-logo" src="https://srfi.schemers.org/srfi-logo.svg" alt="SRFI logo" /></a>170: POSIX API</h1>

<p>by Olin Shivers (original author), John Cowan (editor and shepherd), Harold Ancell (implementer and editor)</p>

<h2>Status</h2>

<p>This SRFI is currently in <em>draft</em> status.  Here is <a
    href="https://srfi.schemers.org/srfi-process.html">an
    explanation</a> of each status that a SRFI can hold.  To provide
    input on this SRFI, please send email to <code><a
    href="mailto:srfi+minus+170+at+srfi+dotschemers+dot+org">srfi-170@<span
    class="antispam">nospam</span>srfi.schemers.org</a></code>.  To
    subscribe to the list, follow <a
    href="https://srfi.schemers.org/srfi-list-subscribe.html">these
    instructions</a>.  You can access previous messages via the
    mailing list <a
    href="https://srfi-email.schemers.org/srfi-170">archive</a>.</p>

<ul>
  <li>Received: 2019-05-04</li>
  <li>60-day deadline: 2019-07-05</li>
  <li>Draft #1 published: 2019-05-06</li>
  <li>Draft #2 published: 2019-05-10</li>
  <li>Draft #3 published: 2019-05-15</li>
  <li>Draft #4 published: 2019-06-20</li>
  <li>Draft #5 published: 2019-07-02</li>
  <li>Draft #6 published: 2019-07-22</li>
  <li>Draft #7 published: 2019-10-07</li>
  <li>Draft #8 published: 2020-06-04</li>
  <li>Draft #9 published: 2020-07-21</li>
  <li>Draft #10 published: 2020-08-09</li>
</ul>


<h2>Abstract</h2>

<p>
The host environment is the set of resources, such as the filesystem,
network and processes, that are managed by the operating system on top of
which a Scheme program is executing. This SRFI specifies some of the ways the host
environment can be accessed from within a Scheme program.  It does so by
leveraging widespread support for P<small>OSIX</small>, the Portable
Operating System Interface standardized by the IEEE.  Not all of the
functions of this SRFI are available on all operating systems.
</p>

<h2>Issues</h2>

<p>None at present.</p>

<h2>Rationale</h2>

<p>The I/O and other environmental procedures provided by the various
Scheme standards were designed at a time when operating systems were far
more diverse than they are today, and therefore portability was difficult
or impossible to achieve.  In addition, Scheme has historically focused
on programming-language features rather than the practical needs of
mainstream software development.  Consequently, none of the standards
provide more than a limited set of operations.  Individual implementations
often provide much more, but in incompatible ways.</p>

<p>This SRFI uses the IEEE 1003 P<small>OSIX</small>.1-2017 standard
to provide maximally portable
access to the services of the operating system on which typical Scheme
implementations run.  Almost all operating systems today support all
or part of P<small>OSIX</small>, so the use of this SRFI is mostly
portable, but implementations are definitely not portable.  However,
an implementation of this SRFI can be layered over many existing
implementation-specific interfaces, or directly over a C FFI.  It is
even possible to implement it on top of the JVM and CLR virtual
machines.
</p>

<p>
This SRFI describes a specific P<small>OSIX</small> API for Scheme.
Rather than attempting to compromise between existing implementations,
the scsh system call specification was chosen as a base document.
Consequently, this SRFI is a reduced version of
<a href="https://scsh.net/docu/html/man-Z-H-4.html#node_chap_3">Chapter 3, "System Calls"</a>
of version 0.6.7 of the <i>Scsh Reference Manual</i>.
The numbered headers are aligned with those used in the Reference Manual.
</p>
<p>Scsh 0.6.7 was chosen for two main reasons.  It is fairly old, so most of its operations,
even those which were non-Posix at the time (2006) are now included in Posix, and it has
few or no operations that aren't Posix at all.  In addition, it is politically fairly neutral,
being tied to an obsolete version of Scheme 48, which is not being actively developed.
Scsh 0.7 exists (see Implementation section), but was
not used in designing this SRFI because it is incompletely documented.
</p>
<p>
This SRFI makes no effort to provide all 81 headers, 1191 interfaces, and 51
data types of full P<small>OSIX</small>.  Instead it provides access to a reasonable number of
highly portable interfaces (many of them even available on Windows)
with wrappers to make them more Scheme-like.
In particular, this SRFI excludes:
</p>
<ul>
<li><p>Most operations on file descriptors
  other than converting between them and Scheme ports.
</p></li><li><p>
Everything to do with the creation and management of subprocesses and
communication with them.  The low-level P<small>OSIX</small> operations
are tricky to use, and a future SRFI will provide a higher-level interface.
</p></li><li><p>
Networking operations: see
<a href="https://srfi.schemers.org/srfi-106/srfi-106.html">SRFI 106</a>.
</p></li><li><p>
Date and time operations, as the
P<small>OSIX</small> date and time operations are irregular and awkward.
This SRFI provides only the current time.
</p></li><li><p>
Access to command-line arguments and environment variables, as well
as provisions for exiting a process, as they are already provided by R7RS-small.
</p></li><li><p>
P<small>OSIX</small> file locking, which is notoriously
<a href="http://0pointer.de/blog/projects/locking.html">broken as designed</a>.
Consider the use of dot files (or if necessary
non-portable facilities) instead.
</p></li><li><p>
All provisions for signal handling, as they are complex and require deep
integration with the particular Scheme implementation.
</p></li><li><p>
Memory-mapped I/O, locales, syslog, System V message
queues, and pseudo-TTYs, as they are considered specialized and out of scope.
Future SRFIs may provide interfaces for them.
</p></li>
</ul>
<p>
The use of colons to join record names and fields into the name of a
record accessor is a convention of Scheme 48, on which scsh is built.
</p>

<p>Note: This SRFI is already very long, and adding detailed examples would
make it even longer.  However,
<a href="https://github.com/scheme-requests-for-implementation/srfi-170/blob/master/srfi/chibi-scheme/lib/srfi/170/test.sld">the Chibi test suite</a>
is a good source of usage examples.</p>

<h2>Specification</h2>

<p>
Implementations of this SRFI on non-P<small>OSIX</small> systems, especially Windows,
must provide all the procedure names and syntax keywords.
However, if the specified action is not possible, the procedure should
either take no action and return some reasonable default value,
or raise an exception.
</p>
<p>A Scheme implementation that supports both this SRFI and multiple
threads of control must ensure that when a thread invokes a blocking I/O
procedure defined below, only that thread is blocked and not any other
concurrently running ones.
Because Scheme threads may be multiplexed on top of P<small>OSIX</small>
threads, the per-thread P<small>OSIX</small> functions may not do the
right thing.
</p>

<h3>3.1&nbsp;&nbsp;Error handling</h3>
<p>
The procedures of this SRFI signal an exception
when the underlying system calls fail.  This is fully documented in
<a href="https://srfi.schemers.org/srfi-198/srfi-198.html">SRFI 198</a>,
which may not yet be finalized when you are reading this.
However, the <code>foreign-status?</code> predicate from that SRFI
will detect the condition objects raised by the procedures
of this SRFI.
</p>

<h3 id="node_sec_3.2">3.2&nbsp;&nbsp;I/O</h3>
<p></p>
<p>Dealing with P<small>OSIX</small> file descriptors in a Scheme environment is difficult.
In P<small>OSIX</small>, open files are part of the process environment, and are referenced
by small exact integers called <i>file descriptors</i>. Open file descriptors are
the fundamental way I/O redirections are passed to subprocesses and executed
programs, since file descriptors are preserved across <code>fork</code> and
<code>exec</code> operations.</p>
<p>
Scheme, on the other hand, uses ports for specifying I/O sources and sinks.
Ports are garbage-collected Scheme objects, not integers.
When a port is garbage collected, it is effectively closed,
but whether the underlying file descriptor is closed is left as an implementation detail.
Because file
descriptors are just integers, it's impossible to garbage collect them &mdash; you
wouldn't be able to close file descriptor 3 unless there were no 3's in the
system, and you could further prove that your program would never again
compute a 3. This is difficult at best.</p>
<p>
If a Scheme program only used Scheme ports, and never actually used
file descriptors, this would not be a problem. But Scheme code
needs to descend to the file descriptor level in at least two circumstances:
when interfacing to foreign code, and
when interfacing to a subprocess.
</p><p>
This causes a problem. Suppose we have a Scheme port constructed
on top of file descriptor 3. We intend to execute a successor program that
will expect this file descriptor. If we drop references to the port,
the garbage collector may prematurely close file 3 before we fork
the subprocess.</p>
<p>
Unfortunately, there is no even vaguely portable solution to this problem.
Scsh and Guile undertake heroic measures to
open new file descriptors for ports when the old file descriptors are
repurposed for something else, and to track when closing a port implies
closing its file descriptor or not.
But doing so involves more
changes than an implementation should have to make in order
to provide this SRFI.</p>

<p>Consequently, this SRFI assumes that file descriptors will only
be used at the edges of the program, and that most I/O operations will be
performed on ports.
As an exception, <code>open-file</code> is provided, because
it allows arguments that the Scheme standard does not.  It returns
a file descriptor that can then be converted to a port.
</p>
<p>
<div><code>(open-file <i>fname flags [permission-bits]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>fd</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>open()</code>&nbsp;</div>
<blockquote>
<i>Permission-bits</i> defaults to <code>#o666</code>, but are masked by the current umask.
<i>Flags</i> is an integer bitmask, composed by adding together
one or more of the following constants:
<code>open/read</code>,
<code>open/write</code>,
<code>open/read+write</code>,
<code>open/append</code>,
<code>open/create</code>,
<code>open/exclusive</code>,
<code>open/nofollow</code>,
<code>open/truncate</code>.
<p>It is an error unless exactly one of the <code>open/read</code>, <code>open/write</code>, or
<code>open/read+write</code> flags is provided.</p>
</blockquote>

<p>The following routines allow conversion between ports and file
descriptors.</p>
<div><code>(fdes->textual-input-port <i>fd</i> [<i>buffer-mode</i>])</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(fdes->binary-input-port <i>fd</i> [<i>buffer-mode</i>])</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<div><code>(fdes->textual-output-port <i>fd</i> [<i>buffer-mode</i>])</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(fdes->binary-output-port <i>fd</i> [<i>buffer-mode</i>])</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>port</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>
<p>These procedures wrap a newly created port around the specified file descriptor,
effectively importing it into the Scheme world.
In particular, the textual ports use the same character encoding applied
by default in the underlying implementation.</p>
<p>The <i>buffer-mode</i> argument, if present, is one of the symbols <code>none</code>,
  <code>block</code> (the default), or <code>line</code>.
  When <i>buffer-mode</i> is <code>none</code>,
  bytes are intended to appear from the source or at the destination as soon as possible;
  otherwise, bytes may be accumulated and transmitted as a block.
  When <i>buffer-mode</i> is <code>block</code>, bytes are intended
  to be transmitted as a fixed size block when a buffer is filled.
  When <i>buffer-mode</i> is <code>line</code>, bytes are intended
  to be transmitted as a block when a newline byte <code>#xA</code> is encountered.
</p>
</blockquote>

<div><code>(port-fdes <i>port</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure exposes the file descriptor of a port,
effectively exporting it from the Scheme world.
Alternatively, <code>#f</code> is returned if <i>port</i> does not have a
file descriptor (a string port, for example).
</blockquote><p>
</p>
<div><code>(close-fdes <i>fd</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>undefined</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>close()</code>&nbsp;</div>
<p></p>
<blockquote>
<p>Closes the file descriptor <i>fd</i>.</p>
<p>If <i>fd</i> is associated with a port, it is an error
to do any further operations on that port.
The same is true of calls to <code>close-port</code> on a file descriptor,
if the implementation permits them.
</p>
</blockquote>

<h3>3.3&nbsp;&nbsp;File system</h3>
<p>The following procedures allow access to the
computer's file system.
<p>
<div><code>(create-directory <i>fname [permission-bits]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>mkdir()</code>&nbsp;</div>
<div><code>(create-fifo <i>fname [permission-bits]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>mkfifo()</code>&nbsp;</div>
<div><code>(create-hard-link <i>old-fname new-fname</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>link()</code>&nbsp;</div>
<div><code>(create-symlink <i>old-fname new-fname</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>symlink()</code>&nbsp;</div>

<blockquote><p>
These procedures create objects of various kinds in the file system.
If an object with the same name already exists, an exception is raised.</p>
<p>
The <i>permission-bits</i> for <code>create-directory</code> default to <code>#o775</code>, and for <code>create-fifo</code> <code>#o664</code>, but are masked by the current umask.
<p>
</p><p>
If you try to create a hard link
and <i>old-fname</i> and <i>new-fname</i> refer to the same file, it is an error
(and your file may be destroyed).
</p></blockquote>

<div><code>(read-symlink <i>fname</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>readlink()</code>&nbsp;</div>
<blockquote>Return the filename referenced by the symlink <i>fname</i>.
</blockquote>
<div><code>(rename-file <i>old-fname new-fname</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>rename()</code>&nbsp;</div>
<blockquote>If you override an existing object, then <i>old-fname</i>
and <i>new-fname</i> must type-match &mdash; either both directories,
or both non-directories.
This is required by the semantics of P<small>OSIX</small> <code>rename()</code>.<p>
</p>
<blockquote><i>Remark: </i>
There is an unfortunate atomicity problem with the <code>rename-file</code>
procedure: if you create file <code>new-fname</code> sometime between
<code>rename-file</code>'s existence check and the actual rename operation,
your file will be clobbered with <code>old-fname</code>. There is no way to
prevent this problem; at least it is highly unlikely to occur in practice.
</blockquote><p>
</blockquote><p>
</p>
<p></p>
<div><code>(delete-directory <i>fname</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>rmdir()</code>&nbsp;</div>
<blockquote>This procedure deletes directories from the file system.
It is an error if <i>fname</i> is not a directory or is not empty.
</blockquote>
<div><code>(set-file-mode <i>fname mode-bits</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>chmod()</code>&nbsp;</div>
<div><code>(set-file-owner <i>fname uid</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>chown()</code>&nbsp;</div>
<div><code>(set-file-group <i>fname gid</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>chown()</code>&nbsp;</div>

<blockquote>
These procedures set the mode bits, owner id, and group id of a
file, respectively, specified by supplying the filename.
Setting file ownership usually requires root privileges.
These procedures follow symlinks and change
the files to which they refer.
</blockquote><p>
</p>
<p></p>
<p></p>
<div><code>(set-file-timespecs <i>fname [access-timespec modify-timespec]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>utimensat()</code>&nbsp;</div>

<blockquote>
This procedure sets the access and modified times for the file
<i>fname</i> to the supplied SRFI 174 timespec values.
If neither time argument is supplied, they are both taken to be
the current time.
The constants <code>timespec/now</code> and <code>timespec/omit</code>
are bound to values used to specify the current time and an unchanged
time respectively.
It is an error if exactly one time is provided.
This procedure
will follow symlinks and set the times of the file to which it refers.
If the procedure completes successfully, the file's time of last
status-change (<code>ctime</code>) is set to the current time.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<div><code>(truncate-file <i>fname/port len</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>truncate()</code>&nbsp;</div>
<blockquote>The specified file is truncated to <i>len</i> bytes in length.
</blockquote><p>
</p>
<p></p>
<p></p>
<p></p>
<div><code>(file-info <i>fname/port follow?</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>file-info-record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>stat()</code>&nbsp;</div>
<blockquote>
The <code>file-info</code> procedure
returns a file-info record containing useful
information about a file.
If the <i>follow?</i> flag is true the procedure will follow symlinks and
report on the file to which they refer.  If <i>follow?</i> is false
the procedure checks the actual file itself, even if it's a symlink.
The <i>follow?</i> flag is ignored if the file argument is a port.
</blockquote>
<div><code>(file-info? <i>obj</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <code>#t</code> if <i>obj</i> is a file-info object and <code>#f</code> otherwise.
</blockquote>

<div><code>(file-info:device <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:inode <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:mode <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:nlinks <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:uid <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:gid <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:rdev <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:size <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:blksize <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:blocks <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:atime <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>timespec</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:mtime <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>timespec</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(file-info:ctime <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>timespec</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><p>Returns the device number, inode number, mode (permission and file type bits),
number of hard links, user id, group id, device ID if file is special,
size in bytes, optimal blocksize for I/O, number of 512B blocks allocated,
last access time, last modification time, and
last change of status times (using SRFI 174 timespecs) stored in <i>file-info</i> respectively.
</p><p>
Although P<small>OSIX</small> does not standardize bit positions in the
file mode, the following assignments are de facto standards
(all except the socket, symlink, and fifo values
have been present and unchanged since the Sixth Edition of Research Unix):</p>

<pre>
#o140000   socket file
#o120000   symbolic link file
#o100000   regular file
#o60000    block device file
#o40000    directory file
#o20000    character device file
#o10000    fifo or pipe file
#o4000     setuid file
#o2000     setgid file
#o1000     sticky directory (restrictions on deletion)
#o400      user read permission
#o200      user write permission
#o100      user execute permission
#o40       group read permission
#o20       group write permission
#o10       group execute permission
#o4        other user read permission
#o2        other user write permission
#o1        other user execute permission
</pre>

<p>Note that to distinguish between file types it is necessary to
examine several bits.</p>

</blockquote>
<p></p>
<div><code>(file-info-directory? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>S_ISDIR()</code>&nbsp;</div>
<div><code>(file-info-fifo? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>S_ISFIFO()</code>&nbsp;</div>
<div><code>(file-info-symlink? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>S_ISLNK()</code>&nbsp;</div>
<div><code>(file-info-regular? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>S_ISREG()</code>&nbsp;</div>
<div><code>(file-info-socket? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>S_IFIFO()</code>&nbsp;</div>
<div><code>(file-info-device? <i>file-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>S_ISCHR() || S_ISBLK()</code>&nbsp;</div>

<blockquote>
These procedures are file-type predicates that test the
file type stored in <i>file-info</i>.
<p>
This SRFI does not provide a special means for checking the
permission bits in a <code>file-info</code> record,
though they are available in <code>file-info:mode</code>.
There are several problems with such procedures.
First, there's an
atomicity issue. In between checking permissions for a file and then trying
an operation on the file, another process could change the permissions,
so a return value from these functions guarantees nothing. Second,
Posix special-cases permission checking when the uid is 0 (<code>root</code>)
&mdash; if the file exists, root is assumed to have the requested permission.
However, not even root can write a file stored on a read-only file system,
such as a CD-ROM.</p>
</blockquote>
<p></p>
<p></p>
<div><code>(directory-files <i>dir [dotfiles?]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>string list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return a list of filenames in directory <i>dir</i>.
The <i>dotfiles?</i> flag (default <code>#f</code>) causes dot files to be
included in the list.
Regardless of the value of <i>dotfiles?</i>, the two files <code>.</code> and
<code>..</code> are <i>never</i> returned.<p>
The directory <i>dir</i> is not prepended to each filename in the
result list. That is,
</p>
<blockquote><code>(directory-files "/etc")</code></blockquote>returns
<blockquote><code>("chown" "exports" "fstab" <code>...</code>)</code></blockquote><i>not</i>
<blockquote><code>("/etc/chown" "/etc/exports" "/etc/fstab" <code>...</code>)</code></blockquote>To use the filenames in the returned list, the programmer can either manually
prepend the directory,
or change to the directory before using the filenames.
</blockquote>

<div><code>(make-directory-files-generator <i>dir [dotfiles?]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>generator</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
Return a SRFI 158 generator of the filenames in directory <i>dir</i>.
The <i>dotfiles?</i> flag (default <code>#f</code>) causes dot files to be
included in the list.
Regardless of the value of <i>dotfiles?</i>, the two files <code>.</code> and
<code>..</code> are <i>never</i> returned.
<p>Like <code>directory-files</code> above, the directory <i>dir</i>
is not prepended to each filename in the results the generator returns.</p>
<p>The generator approach is particularly useful when the number of
items in a directory might be &quot;huge&quot;, which has been a
common paradigm when using a file system as a document database.</p>
<p>Note that the generator must be run to exhaustion to close the underlying
open directory object.</p>
</blockquote>

<div><code>(open-directory <i>dir [dot-files?]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>directory-object</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>opendir()</code>&nbsp;</div>
<div><code>(read-directory <i>directory-object</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>string or eof-object</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>readdir()</code>&nbsp;</div>
<div><code>(close-directory <i>directory-object</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>undefined</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>closedir()</code>&nbsp;</div>
<p>
These functions implement an interface to the
<code>opendir()</code>/
<code>readdir()</code>/
<code>closedir()</code>
family of functions for processing directories.
</p><p>
The <code>open-directory</code> procedure opens the
directory with the specified pathname for reading, returning an opaque directory object.
Then <code>read-directory</code>
returns the name of the next available file,
or the end of file object if there are no more files.
The <code><i>dot-files?</i></code> argument controls whether filenames beginning with &quot;<code>.</code>&quot; are returned.
If it is <code>#f</code>, which is the default, they are not.  The filenames <code>.</code> and <code>..</code> are <i>never</i> returned.
Finally, <code>close-directory</code> closes a directory object.</p>

<div><code>(real-path <i>path</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>realpath()</code>&nbsp;</div>

<blockquote>
Returns an absolute pathname
derived from <i>pathname</i> that names the same file
and whose resolution does not involve <code>.</code>, <code>..</code>, or symlinks.
</blockquote>

<div><code>temp-file-prefix</code> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<i>string parameter</i>&nbsp;</div>
<p></p>
<blockquote>
A SRFI 39 or R7RS parameter that returns a string when invoked.  Its initial value is
the value of the environment variable <code>TMPDIR</code> concatenated with <code>"/<i>pid</i>"</code>
if <code>TMPDIR</code> is set and to
<code>"/tmp/<i>pid</i>"</code> otherwise, where <i>pid</i> is the id of the current process.
</blockquote>
<div><code>(create-temp-file <i>[prefix]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Creates a new temporary file and returns its name.
The optional argument specifies the filename prefix to use, and defaults
to the result of invoking <code>temp-file-prefix</code>.
The procedure generates a sequence of filenames that have <i>prefix</i> as
a common prefix, looking for a filename that doesn't already exist in the
file system. When it finds one, it creates it with permission <code>#o600</code>
and returns the filename. (The file permission can be changed to a more
permissive permission with <code>set-file-mode</code> after being created.)<p>
This file is guaranteed to be brand new. No other process will have it
open. This procedure does not simply return a filename that is very
likely to be unused. It returns a filename that definitely did not exist
at the moment <code>create-temp-file</code> created it.</p>
<p>
It is not necessary for the process's pid to be a part of the filename
for the uniqueness guarantees to hold. The pid component of the default
prefix simply serves to scatter the name searches into sparse regions, so
that collisions are less likely to occur. This speeds things up, but does
not affect correctness.</p>
</blockquote><p>
</p>
<div><code>(call-with-temporary-filename <i>maker [prefix]</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>object</i><sup>+</sup></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>

<blockquote>
This procedure can be used to perform certain atomic transactions on
the file system involving filenames. Some examples:
<ul>
<li>Linking a file to a fresh backup temp name.
</li><li>Creating and opening an unused, secure temp file.
</li><li>Creating an unused temporary directory.
</li></ul><p></p>
<p>
This procedure uses <i>prefix</i> to generate a series of trial
filenames.  <i>Prefix</i> is a string, and
defaults to the value of invoking <code>temp-file-prefix</code>.
File names are generated by
concatenating <i>prefix</i>
with a varying string.<p>
The <i>maker</i> procedure is called serially on each filename
generated.  It must return at least one value; it may return multiple
values. If the first return value is <code>#f</code> or if <i>maker</i> raises an
exception indicating that the file exists
<code>call-with-temporary-filename</code> will loop,
generating a new filename and calling <i>maker</i> again. If the first
return value is true, the loop is terminated, returning whatever value(s)
<i>maker</i> returned.</p>
<p>
After a number of unsuccessful trials, <code>call-with-temporary-filename</code> may give up
and signal an error.</p>
<p>
To rename a file to a temporary name:
</p>
<blockquote><code>
(call-with-temporary-filename&nbsp;(lambda&nbsp;(backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(create-hard-link&nbsp;old-file&nbsp;backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;backup)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;".temp.")&nbsp;;&nbsp;Keep&nbsp;link&nbsp;in&nbsp;current working directory.<br>
(delete-file&nbsp;old-file)</code></blockquote>
Recall that this SRFI reports procedure failure by raising an error
exception, not by returning an error code. This is critical for
this example &mdash; the programmer can assume that if the
<code>call-with-temporary-filename</code> call returns, it returns successfully.
So the following <code>delete-file</code> call can be reliably invoked,
safe in the knowledge that the backup link has definitely been established.<p>
To create a unique temporary directory:
</p>
<blockquote><code>
(call-with-temporary-filename&nbsp;(lambda&nbsp;(dir)&nbsp;(create-directory&nbsp;dir)&nbsp;dir)<br>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"/tmp/tempdir.")</code></blockquote>
Similar operations can be used to generate unique fifos,
or to return values other than the new filename (for example, an open port).
</blockquote>

<h3 id="node_sec_3.4">3.4&nbsp;&nbsp;[Intentionally omitted]</h3>

<p></p>
<h3 id="node_sec_3.5">3.5&nbsp;&nbsp;Process state</h3>
<p></p>
<p></p>
<p></p>
<div><code>(umask)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P<small>OSIX</small> umask()&nbsp;</div>
<blockquote>
Returns the current file protection mask, or umask, as an exact integer.
Whenever a file is created, the specified or default permissions are
bitwise-anded with the complement of the umask before they are used.
</blockquote>
<div><code>(set-umask!&nbsp;<i>umask</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>unspecified</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure) &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;P<small>OSIX</small> umask()&nbsp;</div>
<blockquote>
<p>Sets the file protection mask to the exact integer <i>umask</i>
and returns an unspecified value.</p>
<p><b>Warning:</b>
Although P<small>OSIX</small> specifies that changing the umask
affects all threads in the current process, some Scheme implementations
maintain a separate simulated umask for each thread.
As a result, the effects of this procedure in a multi-threaded
program are only partly predictable.
This SRFI recommends that in multi-threaded programs the mask
be set in the primordial thread before any other threads are created
and never changed again.</p>
</blockquote>
<p></p>
<p></p>
<div><code>(current-directory)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>string</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>getcwd()</code>&nbsp;</div>
<blockquote>
Returns the current directory as a string containing an absolute pathname.
Whenever a file is referenced with a relative path, it is interpreted as
relative to this directory.
</blockquote>
<div><code>(set-current-directory!&nbsp;<i>new-directory</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>unspecified</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>chdir()</code>&nbsp;</div>
<blockquote>
<p>Sets the current directory to <i>new-directory</i>
and returns an unspecified value.</p>
<p><b>Warning:</b>
Although P<small>OSIX</small> specifies that changing the current directory
affects all threads in the current process, some Scheme implementations
maintain a separate simulated current directory for each thread.
As a result, the effects of this procedure in a multi-threaded
program are only partly predictable.
This SRFI recommends that in multi-threaded programs the current directory
be set in the primordial thread before any other threads are created
and never changed again.</p>
</blockquote>
<p></p>
<p></p>
<div><code>(pid<i></i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>getpid()</code>&nbsp;</div>
<blockquote>
Retrieves the process id for the current process.
</blockquote>

<div><code>(nice <i>[delta]</i>)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>nice()</code>&nbsp;</div>
<blockquote><p>
Increments the niceness of the current process by <i>delta</i>.
The lower the <i>niceness</i> value is, the more the process is favored during scheduling.
If <code><i>delta</i></code> is not specified, the increment is 1.
</p>
<p>Real-time processes are not affected by <code>nice</code>.</p>
</blockquote><p>
</p>
<div><code>(user-uid<i></i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>getuid()</code>&nbsp;</div>
<div><code>(user-gid<i></i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>getgid()</code>&nbsp;</div>
<div><code>(user-effective-uid<i></i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>geteuid()</code>&nbsp;</div>
<div><code>(user-effective-gid<i></i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>exact integer</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>getegid()</code>&nbsp;</div>
<div><code>(user-supplementary-gids<i></i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>exact integer</i> list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>getgroups()</code>&nbsp;</div>

<blockquote>
For the calling process, these routines get the specified data.  The scsh proceedure <code>user-login-name</code> that uses <code>getlogin()</code> or <code>getlogin_r()</code> can be simulated with <code>(user-info.name (user-info (user-uid)))</code>, using procedures that are described in the next section.
</blockquote><p>
</p>

<h3 id="node_sec_3.6">3.6&nbsp;&nbsp;User and group database access</h3>
<p>These procedures are used to access the user and group databases
(for example, the ones traditionally stored in <code>/etc/passwd</code> and <code>/etc/group</code>).</p>
<p>
</p>
<p></p>
<p></p>
<div><code>(user-info <i>uid/name</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>getpwuid/getpwnam()</code>&nbsp;</div>

<blockquote>
Return a <code>user-info</code> record giving the recorded information for a
particular user.
The <i>uid/name</i> argument is either an exact integer uid or a string user name.
If <i>uid/name</i> does not identify an existing user, <code>#f</code> is returned;
this does not constitute an error situation,
and callers must be prepared to handle it.
</blockquote><p>
</p>
<p></p>
<div><code>(user-info? <i>obj</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <code>#t</code> if <i>obj</i> is a user info object and <code>#f</code> otherwise.
</blockquote>
<div><code>(user-info:name <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(user-info:uid <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(user-info:gid <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(user-info:home-dir <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(user-info:shell <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the user name, user id, group id, home directory,
and shell path stored in <i>user-info</i> respectively.
Windows returns <code>#f</code> for any items it doesn't have.</blockquote>

<div><code>(user-info:full-name <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the contents of the <code>pw_gecos</code> field
stored in <i>user-info</i>.
Although this field is not part of P<small>OSIX</small>,
it has been part of all Unix variants since at least
the Sixth Edition of Research Unix.
It normally contains the user's full name, but may contain additional
system-specific information;
on Windows, it contains exactly the full name.</blockquote>

<div><code>(user-info:parsed-full-name <i>user-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>string list</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote><p>Returns a parsed and expanded version of the raw string
returned by <code>user-info:full-name</code>.
The raw value is split on commas, creating a list of strings to be
returned.  All ampersands in the first element of the list are
replaced by <code>user-info:name</code>, which is capitalized if it
starts with an ASCII lowercase letter.</p>
<p>However, on Windows the implementation is completely different:
<code>user-info:parsed-full-name</code>
returns a list with a single element, the result of
<code>user-info:full-name</code>.  No comma splitting or
ampersand substitution is performed.</p>
<p>The meaning of the first element of the returned list is the
user's full name on all known systems.  The remaining elements
have varying meaning.  For example, on BSD systems, the second through fourth elements
are the user's work location, the user's work phone number, and the
user's home phone number, respectively.
On Cygwin, the second element is the Windows SID corresponding
to this user; further elements depend on
<a href="https://cygwin.com/cygwin-ug-net/ntsec.html#ntsec-mapping-nsswitch-gecos">Cygwin-specific</a>
entries in the <code>/etc/nsswitch.conf</code> file.</p>
</blockquote>

<div><code>(group-info <i>gid/name</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>record</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>getgrgid/getgrnam()</code>&nbsp;</div>

<blockquote>
Return a <code>group-info</code> record giving the recorded information for a
particular group.
The <i>gid/name</i> argument is either an exact integer gid or a string group name.
If <i>gid/name</i> does not identify an existing group, <code>#f</code> is returned;
this does not constitute an error situation,
and callers must be prepared to handle it.
</blockquote>

<div><code>(group-info? <i>obj</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>boolean</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns <code>#t</code> if <i>obj</i> is a group info object and <code>#f</code> otherwise.
</blockquote>
<div><code>(group-info:name <i>group-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>string</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<div><code>(group-info:gid <i>group-info</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>exact integer</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;</div>
<blockquote>Returns the group name and group id stored in <i>group-info</i>.  The list of group member ids can be retrieved with the above <code>(user-supplementary-gids)</code></blockquote>

<h3 id="node_sec_3.7">3.7&nbsp;&nbsp;[Intentionally omitted]</h3>

<h3 id="node_sec_3.8">3.8&nbsp;&nbsp;[Intentionally omitted]</h3>

<h3 id="node_sec_3.9">3.9&nbsp;&nbsp;[Intentionally omitted]</h3>

<h3 id="node_sec_3.10">3.10&nbsp;&nbsp;Time</h3>
<p>
A <a href="https://srfi.schemers.org/srfi-174/srfi-174.html">SRFI 174</a>
timespec is an object containing two values, the number of elapsed seconds
since a P<small>OSIX</small> epoch, and the number of
elapsed nanoseconds since the beginning of the current second.
The system clock is not required to report time at full nanosecond
resolution, nor is anything guaranteed about accuracy.
</p>

<div><code>(posix-time)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr;&nbsp;&nbsp;&nbsp;<i>timespec</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>clock_gettime()</code>&nbsp;</div>

<blockquote>
<p>The <code>posix-time</code> procedure returns the current time as a
<i>timespec</i> since the P<small>OSIX</small> epoch (midnight January
1, 1970 Universal Time), excluding leap seconds.
</blockquote>

<div><code>(monotonic-time)</code> &nbsp;&nbsp;&nbsp;&nbsp;&rarr;&nbsp;&nbsp;&nbsp;<i>timespec</i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>clock_gettime()</code>&nbsp;</div>

<blockquote>
<p>The same as <code>posix-time</code>, except that the epoch is arbitrary.
This epoch cannot change after the current
program begins to run.
It is guaranteed that a call to <code>monotonic-time</code>
cannot return a time earlier than a previous call to <i>monotonic-time</i>.
This is not guaranteed for <code>posix-time</code>
because the system's P<small>OSIX</small> clock
is sometimes turned either forward or backward.
</p>
</blockquote>

<h3>3.11&nbsp;&nbsp;Environment variables</h3>
<p>R<sup>7</sup>RS provides two procedures (via SRFI 98) to get
environment variables:</p>
<ul>
<li><code>(get-environment-variables)</code></li>
<li><code>(get-environment-variable <i>name</i>)</code></li>
</ul>
<p> Setters have not yet been standardized, so this SRFI provides
them:</p>

<div><code>(set-environment-variable! <i>name</i> <i>value</i>)</code>
&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>undefined</i>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</div>
<blockquote>
Change the value of the environment variable <i>name</i> to
be <i>value</i>. Both <i>name</i> and <i>value</i> are strings.
If <i>name</i> is not defined at the time of call, a new variable is
added; if <i>name</i> is defined, its old value is discarded and
replaced by <i>value</i>. If <i>name</i> or <i>value</i> are invalid
according to the operating system, an exception is raised.
Mutating <i>name</i> or <i>value</i> after the call must not change
the name or value of the environment variable.
</blockquote>

<div><code>(delete-environment-variable! <i>name</i>)</code>
&nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i>undefined</i>
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)</div>
<blockquote>
Remove the environment variable <i>name</i> such that a
subsequent <code>(get-environment-variable <i>name</i>)</code> would
return <code>#f</code>. If the variable cannot be removed, an
exception is raised. If <i>name</i> does not currently have a value,
the call silently succeeds.
</blockquote>

<p><b>Concurrency note:</b> Under most operating systems, environment
variables are per-process, not per-thread. Multi-threaded
implementations should guard against race conditions.</p>

<p><b>Naming note:</b> Many Scheme implementations (including scsh)
use the short procedure names <code>getenv</code>
and <code>setenv</code> (or minor variations). Since the long
name <code>get-environment-variable</code> has been canonized by
R<sup>n</sup>RS and SRFI 98, this SRFI matches it instead. Since
environment variables are OS variables rather than Scheme variables,
it's debatable whether procedures to modify them should bear
the <code>!</code> suffix. MIT Scheme has the suffixed names and we
are not aware of any Scheme implementation with the unsuffixed names,
so the suffix is kept in this SRFI.</p>

<h3 id="node_sec_3.12">3.12&nbsp;&nbsp;Terminal device control</h3>
<p></p>
<p>
</p>
<div><code>(terminal? <i>port</i>)</code> &nbsp;&nbsp;&nbsp;&rarr; &nbsp;&nbsp;&nbsp;<i><i>boolean</i></i> &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;(procedure)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; P<small>OSIX</small> <code>isatty()</code>&nbsp;</div>
<blockquote>
Return true if the argument is a terminal.
Raises an error if <code><i>port</i></code> is not a port,
or if the underlying call to <code>isatty()</code> returns an error
other than <code>ENOTTY</code>.
This procedure is useful when writing programs that change their behavior
when their standard input or output is a terminal.
</blockquote>
<h2>Implementation</h2>

<p>
There are two implementations of this SRFI, <a href="https://scsh.net/">Scsh</a> version 0.7,
<a href="https://github.com/scheme/scsh">which can be found at GitHub in the scsh repository of scheme</a>,
and a Chibi Scheme <code>(srfi 170)</code> library.  You can find the Chibi Scheme example implementation,
and build notes for scsh, in their own <code>srfi</code> subdirectories.
</p>
<p>
Notes on the exceptions and deviations between this SRFI and
the Chibi implementation can be found in those subdirectories, at
<a href="https://github.com/scheme-requests-for-implementation/srfi-170/blob/master/srfi/scsh/NOTES.html">
<code>srfi/chibi-scheme/NOTES.html</code></a>,
and between this SRFI and scsh 0.7 in
<a href="https://github.com/scheme-requests-for-implementation/srfi-170/blob/master/srfi/chibi-scheme/NOTES.html">
<code>srfi/scsh/NOTES.html</code></a>.
</p>

<h2>Acknowledgements</h2>

<p>Thanks to Olin Shivers, <i>sine quo non</i>, and all the Scheme implementors
who have followed his work.  Thanks also to all the participants in the
SRFI mailing list.</p>

<p>(Why <i>quo</i>?  Because in <i>sine qua non</i>
the pronoun is feminine, agreeing with <i>re</i> 'thing' understood,
whereas Olin is masculine.)</p>

<h2>Copyright</h2>
Copyright &copy; 2019 by John Cowan.

<p>
  Permission is hereby granted, free of charge, to any person
  obtaining a copy of this software and associated documentation files
  (the "Software"), to deal in the Software without restriction,
  including without limitation the rights to use, copy, modify, merge,
  publish, distribute, sublicense, and/or sell copies of the Software,
  and to permit persons to whom the Software is furnished to do so,
  subject to the following conditions:

<p>
  The above copyright notice and this permission notice shall be
  included in all copies or substantial portions of the Software.

<p>
  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
  SOFTWARE.

<p>This SRFI is derived from the documentation for
  <a href="https://scsh.net/">scsh</a>, whose copyright notice, from
  the <code>COPYING</code> file, is reprinted here:</p>

<blockquote>
  <div>Copyright (c) 1993-2003 Richard Kelsey and Jonathan Rees</div>
  <div>Copyright (c) 1994-2003 by Olin Shivers and Brian D. Carlstrom.</div>
  <div>Copyright (c) 1999-2003 by Martin Gasbichler.</div>
  <div>Copyright (c) 2001-2003 by Michael Sperber.</div>
  <div>Copyright (c) 2019-2020 by John Cowan and Harold Ancell.</div>
  <p>All rights reserved.</p>
  <p>Redistribution and use in source and binary forms, with or without
  modification, are permitted provided that the following conditions
  are met:</p>
  <ol><li>Redistributions of source code must retain the above copyright
      notice, this list of conditions and the following disclaimer.</li>
  <li>Redistributions in binary form must reproduce the above copyright
     notice, this list of conditions and the following disclaimer in the
     documentation and/or other materials provided with the distribution.</li>
  <li>The name of the authors may not be used to endorse or promote products
     derived from this software without specific prior written permission.</li>
  </ol>
  <p>THIS SOFTWARE IS PROVIDED BY THE AUTHORS ``AS IS'' AND ANY EXPRESS OR
  IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
  OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
  IN NO EVENT SHALL THE AUTHORS BE LIABLE FOR ANY DIRECT, INDIRECT,
  INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
  NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
  DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
  THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
  THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.</p></blockquote>

  <hr>
  <address>Editor: <a href="mailto:srfi-editors+at+srfi+dot+schemers+dot+org">Arthur A. Gleckler</a></address></body></html>
